
<!DOCTYPE html>
<html lang="en">
<head>
    <title>0.2.6版本 - Lor Framework</title>
        <meta charset="utf-8">
        <meta name="description" content="Lor - A fast, minimalist web framework based on OpenResty.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <meta property="og:type" content="article">
        <meta property="og:title" content="lor">


        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="lor">
        <meta name="twitter:description" content="Lor - A fast, minimalist web framework based on OpenResty.">
        <meta name="twitter:image" content="http://lor.sumory.com/images/logo.png">

        <link rel="icon" href="/images/logo.png" type="image/x-icon">
        <link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono" rel="stylesheet" type="text/css">
        <link href="//fonts.googleapis.com/css?family=Dosis:500&amp;text=Vue.js" rel="stylesheet" type="text/css">


    <!-- main page styles -->
    
        <link rel="stylesheet" href="/css/page.css?v=0.3.1_0">
    

    <script>window.PAGE_TYPE = "api"</script>
    <style>

    </style>
</head>
<body class="docs">    <div id="mobile-bar" >
        <a class="menu-button"></a>
        <a class="logo" href="/"></a>
    </div>
    <div id="header">
  <a id="logo" href="/">
    <img style="display: inline-block;" src="/images/logo.png">
    <!-- <span>Lor</span> -->
  </a>
  <ul id="nav">
    <!-- <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li> -->
<li><a href="/guide/" class="nav-link">教程</a></li>
<li><a href="/api/" class="nav-link current">API</a></li>
<li><a href="/examples/" class="nav-link">示例</a></li>
<li><a href="/release/" class="nav-link">Releases</a></li>
<!-- <li><a href="/blog/" class="nav-link">Blog</a></li> -->
<li><a href="/migration/" class="nav-link">0.2 to 0.3</a></li>

<!-- <li class="nav-dropdown-container language">
  <a class="nav-link">多语言</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://lor.sumory.com/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://lor.sumory.com/" class="nav-link" target="_blank">English</a></li>
  </ul>
</li>
 -->

  </ul>
</div>

    
        <div id="main" class="fix-sidebar">
            
    <div class="sidebar scrollbar">
    <ul class="main-menu">
        <!-- <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li> -->
<li><a href="/guide/" class="nav-link">教程</a></li>
<li><a href="/api/" class="nav-link current">API</a></li>
<li><a href="/examples/" class="nav-link">示例</a></li>
<li><a href="/release/" class="nav-link">Releases</a></li>
<!-- <li><a href="/blog/" class="nav-link">Blog</a></li> -->
<li><a href="/migration/" class="nav-link">0.2 to 0.3</a></li>

<!-- <li class="nav-dropdown-container language">
  <a class="nav-link">多语言</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://lor.sumory.com/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://lor.sumory.com/" class="nav-link" target="_blank">English</a></li>
  </ul>
</li>
 -->

    </ul>
    <div class="list">
        
            <ul class="menu-root">
                <li><h3 style="margin-top:0px;">API</h3></li>
                
                        <li>
                            <a href="/api/index.html" class="sidebar-link">0.3.1版本</a>
                        </li>
                
                        <li>
                            <a href="/api/v0_3_0.html" class="sidebar-link">0.3.0版本</a>
                        </li>
                
                        <li>
                            <a href="/api/v2.html" class="sidebar-link current">0.2.6版本</a>
                        </li>
                
            </ul>
        
    </div>
</div>


<div class="content api with-sidebar ">
   <!--  
      <h2 style="margin-top:4px;">0.2.6版本</h2>
     -->

    <h2 id="lor"><a href="#lor" class="headerlink" title="lor"></a>lor</h2><figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> lor = <span class="built_in">require</span>(<span class="string">"lor.index"</span>)</div></pre></td></tr></table></figure>
<p>lor对象: lor框架暴露出来的最重要对象，理论上通过调用该对象的方法和属性即可使用绝大部分lor框架提供的功能。</p>
<h3 id="lor-1"><a href="#lor-1" class="headerlink" title="lor()"></a>lor()</h3><figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> lor = <span class="built_in">require</span>(<span class="string">"lor.index"</span>)</div><div class="line"><span class="keyword">local</span> app = lor()</div></pre></td></tr></table></figure>
<p>该方法是框架暴露出来的最重要的方法，用于创建一个app对象，之后大部分api将通过<code>app</code>对象展开.<br>如无特别说明，下文中出现的<code>app</code>均指通过<code>lor()</code>方法创建的application对象.</p>
<h3 id="lor-Router"><a href="#lor-Router" class="headerlink" title="lor:Router()"></a>lor:Router()</h3><p>生成一个<code>group router</code>对象，<code>group router</code>对象指一个<code>路由组</code>，用来在业务上聚合一组相关的路由，它具有<code>get</code>、<code>post</code>、<code>delete</code>、<code>put</code>等等HTTP方法，这些API与下文介绍的<code>app</code>上的<code>get</code>、<code>post</code>、<code>delete</code>、<code>put</code>等方法使用方式一致。</p>
<h2 id="app对象"><a href="#app对象" class="headerlink" title="app对象"></a>app对象</h2><p>app对象即为由<code>lor()</code>方法生成的对象， 用它来配置各种参数和路由。</p>
<h3 id="app-conf-key-value"><a href="#app-conf-key-value" class="headerlink" title="app:conf(key, value)"></a>app:conf(key, value)</h3><p>application配置项，目前主要用于html模板配置，提供一下四个配置项：</p>
<ul>
<li>app:conf(“view enable”, true), 开启模板功能，默认为关闭</li>
<li>app:conf(“view engine”, “tmpl”)， 配置模板引擎，当前lor只支持lua-resty-template，所以这个值暂时固定为”tmpl”</li>
<li>app:conf(“view ext”, “html”)，模板文件后缀，用户可自由配置</li>
<li>app:conf(“views”, “./app/views”)，模板文件所在路径</li>
</ul>
<h3 id="app-use-path-middleware"><a href="#app-use-path-middleware" class="headerlink" title="app:use(path, middleware)"></a>app:use(path, middleware)</h3><ul>
<li>app:use用于加载一个插件(middleware)</li>
<li><p>参数说明</p>
<ul>
<li>path, 插件作用的路径，可以为空，也就是说app:use可以只有一个<code>middleware</code>参数，这时插件作用在所有path上</li>
<li>middleware，插件，格式为<code>function(req, res, next) end</code>, 对请求做预处理或者善后处理</li>
</ul>
</li>
<li><p>示例1：</p>
</li>
</ul>
<p>该实例加载了一个作用在所有路径上的插件，它的作用是在请求上注入了一个参数<code>inject_param</code>,这样后续匹配到的路由可以使用这个参数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">app:use(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span></div><div class="line">    <span class="comment">-- 注入一个参数</span></div><div class="line">    req.params.inject_param = <span class="string">"from all path middleware"</span></div><div class="line">    <span class="built_in">next</span>() <span class="comment">-- 注意，如果不调用next()方法，请求到这里就截止了，不在匹配后面的路由</span></div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<p>该实例类似于一个拦截器，app加载了一个作用在前缀为”/user/“路径上的插件。<br>插件的作用是判断传入的请求参数里是否含有已经被授权的token，没有则直接返回错误，如果有就放过，继续下个路由。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">app:use(<span class="string">"/user"</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> req.params <span class="keyword">or</span> req.params.token ~= <span class="string">"authorized token"</span> <span class="keyword">then</span></div><div class="line">        <span class="comment">-- 注意，这里没有调用next()方法，请求到这里就截止了，不在匹配后面的路由</span></div><div class="line">        res:status(<span class="number">403</span>):send(<span class="string">"not allowed reqeust"</span>)</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">next</span>() <span class="comment">-- 满足以上条件，那么继续匹配下一个路由</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<h3 id="app-erroruse-path-middleware"><a href="#app-erroruse-path-middleware" class="headerlink" title="app:erroruse(path, middleware)"></a>app:erroruse(path, middleware)</h3><ul>
<li>app:erroruse用于加载一个错误处理插件(middleware)</li>
<li><p>参数说明</p>
<ul>
<li>path, 插件作用的路径，可以为空，也就是说app:erroruse可以只有一个<code>middleware</code>参数，这时插件作用在所有path上</li>
<li>middleware，插件，格式为<code>function(err, req, res, next) end</code>, 注意与<code>use</code> api不同的是这个function有4个参数.</li>
</ul>
</li>
<li><p>示例1：</p>
</li>
</ul>
<p>该实例加载了一个作用在所有路径上的插件，也就是说只要有地方发生了错误，并且没有显式地调用<code>response</code>对象的<code>输出</code>方法，则会路由到这个错误插件进行处理。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 统一错误处理插件</span></div><div class="line">app:erroruse(<span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span></span></div><div class="line">    <span class="comment">-- err是错误对象，直接将err打到response，生产环境请勿这样做</span></div><div class="line">    res:status(<span class="number">500</span>):send(err)</div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<p>该实例加载了一个作用在前缀为”/user/“路径上的错误插件，也就是以”/user/“开始的请求处理过程中如果发生了错误就会被路由到这里做处理.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">app:erroruse(<span class="string">"/user"</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span></span></div><div class="line">    <span class="comment">-- ...</span></div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<h3 id="app-run"><a href="#app-run" class="headerlink" title="app:run()"></a>app:run()</h3><p>启动lor项目，开始接受请求并处理。</p>
<h3 id="app-get-path-fn"><a href="#app-get-path-fn" class="headerlink" title="app:get(path, fn)"></a>app:get(path, fn)</h3><ul>
<li>目前lor支持的HTTP方法有get、post、head、options、put、patch、delete、trace，这些方法都可以用类似于app:get(path, fn)的形式调用。</li>
<li><p>参数说明</p>
<ul>
<li>path，有两种格式，<ul>
<li>纯字符串形式，如”/user/1”,”/foo/bar”</li>
<li>含有变量的uri， 如”/user/:id”，那么”/user/123”解析后将生成一个变量req.params.id，值为123</li>
</ul>
</li>
<li>fn，对应这个uri的请求处理匿名函数，格式为function(req, res, next) end， 也可将它理解为一个通用的lor插件</li>
</ul>
</li>
<li><p>示例:</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">app:get(<span class="string">"/index"</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span></div><div class="line">    res:send(<span class="string">"hello world!"</span>)</div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<h2 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h2><p>我们注意到有大量的地方出现了形如<code>function(req, res, next) end</code>的函数，这个函数其实就是lor框架的核心机制，也就是lor的常规插件。<br>其中的<code>req</code>指的就是request对象，它包装了OpenResty收到的HTTP请求参数，并附带了一些方法来完成session、cookie数据交互，路由处理等其他后续操作。</p>
<p>req的常用属性和方法介绍如下：</p>
<h3 id="req-path"><a href="#req-path" class="headerlink" title="req.path"></a>req.path</h3><p>请求的uri，一般用作框架内部使用，如处理路由，解析参数，重定向请求等等，若用户不清楚修改该值会有什么影响，切勿随意更改此值。</p>
<h3 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h3><p>这是一个table，指的是url解析后的query string，比如”/find/user?id=1&amp;name=sumory&amp;year=2016”被解析后会生成对象req.query,它的值为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    id = <span class="string">"1"</span>,</div><div class="line">    name = <span class="string">"sumory"</span>,</div><div class="line">    year = <span class="string">"2016"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h3><p>这是一个table，指的是url解析后的path variable，比如声明了以下路由处理方法</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">app:get(<span class="string">"/query/:id/book/:name"</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span></div><div class="line">    <span class="keyword">local</span> params = req.params</div><div class="line"><span class="keyword">end</span>)</div></pre></td></tr></table></figure>
<p>那么访问”/query/123/book/abc”这个uri时得到的req.params值为:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    id = <span class="string">"123"</span>,</div><div class="line">    name = <span class="string">"abc"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h3><p>这是一个table，指的是form表单提交上来的数据。</p>
<h3 id="req-is-found"><a href="#req-is-found" class="headerlink" title="req:is_found()"></a>req:is_found()</h3><p>用于判断uri是否被路由到，如果这个方法返回值最终为false，说明<code>404</code>了。</p>
<h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p>reponse对象指的是<code>function(req, res, next) end</code>函数中的res，它包装了OpenResty处理HTTP响应的一些API，并附带了一些方法来完成诸如模板渲染、重定向、json返回、session/cookie处理等其他后续操作。</p>
<p>res的常用属性和方法介绍如下：</p>
<h3 id="res-render-view-data"><a href="#res-render-view-data" class="headerlink" title="res:render(view, data)"></a>res:render(view, data)</h3><ul>
<li>渲染html页面，响应头Content-Type值为text/html; charset=UTF-8</li>
<li>参数说明<ul>
<li>view，模板文件路径，比如app:conf(“views”, “./app/views”)设置了模板路径为./app/views，那么想使用模板文件./app/views/user/index.html时，这个值应为”user/index”</li>
<li>data，类型为table，指得是模板文件渲染时需要的数据</li>
</ul>
</li>
</ul>
<h3 id="res-html-content"><a href="#res-html-content" class="headerlink" title="res:html(content)"></a>res:html(content)</h3><ul>
<li>返回内容为”content”的html，响应头Content-Type值为text/html; charset=UTF-8</li>
<li>参数说明：content应为字符串类型</li>
</ul>
<h3 id="res-json-data"><a href="#res-json-data" class="headerlink" title="res:json(data)"></a>res:json(data)</h3><ul>
<li>返回内容为json格式，响应头Content-Type值为application/json; charset=utf-8</li>
<li>参数说明：data格式因为lua table</li>
</ul>
<h3 id="res-send-text"><a href="#res-send-text" class="headerlink" title="res:send(text)"></a>res:send(text)</h3><ul>
<li>返回内容为text，响应头Content-Type值为text/plain; charset=UTF-8</li>
<li>参数说明：text应为字符串、数字或是array等类型</li>
</ul>
<h3 id="res-set-header-key-value"><a href="#res-set-header-key-value" class="headerlink" title="res:set_header(key, value)"></a>res:set_header(key, value)</h3><ul>
<li>设置响应头，即调用<code>ngx.header[key] = value</code></li>
</ul>
<h3 id="res-cookie-set-…"><a href="#res-cookie-set-…" class="headerlink" title="res.cookie.set(…)"></a>res.cookie.set(…)</h3><ul>
<li>设置cookie，底层使用lua-resty-cookie库，请自行查看该库参数格式</li>
<li>参数说明，两种使用方式:<ul>
<li>res.cookie.set({key = “c2”, value = “c2_value”})</li>
<li>res.cookie.set(“c1”, “c1_value”)</li>
</ul>
</li>
</ul>
<h3 id="res-redirect-url"><a href="#res-redirect-url" class="headerlink" title="res:redirect(url)"></a>res:redirect(url)</h3><ul>
<li>重定向，即调用<code>ngx.redirect(url)</code></li>
</ul>
<h2 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h2><p><code>function(req, res, next) end</code>函数中的形参next是lor pipeline式路由能顺利进行的关键，它有两种调用方式：</p>
<ul>
<li>不带参数，直接调用next()，则会将请求传给下一个调用者，继续后面的处理</li>
<li>带参数，如next(“something”)，这时会跳过之后的调用，直接去寻找能匹配的”错误处理插件”</li>
</ul>

    
      <div class="guide-links">
        
          <span>← <a href="/api/v0_3_0.html">0.3.0版本</a></span>
        
        
      </div>
    
    <div class="footer">
      发现错误？想参与编辑？
      <a href="https://github.com/sumory/lor.sumory.com/blob/master/src/api/v2.md" target="_blank">
        在 Github 上编辑此页！
      </a>
    </div>
</div>

        </div>
        <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/common.js?v=0.3.1_1"></script>
</body>
</html>
